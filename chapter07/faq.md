# Задачи
### Функция `sum` принимает срез чисел и складывает их вместе. Как бы выглядела сигнатура этой функции?
```go
func sum(sl []int) int {}
```
***
### Напишите функцию, которая принимает число, делит его пополам и возвращает `true` в случае, если получившееся число чётное, и `false` в случае нечетного результата. Например, `half(1)` должна вернуть `(0, false)`, в то время как `half(2)` вернет `(1, true)`.
```go
func oddMod(x int) (int, bool) {
	return x / 2, x%2 == 0
}
```
***
### Напишите функцию с переменным числом параметров, которая находит наибольшее число в списке.
```go
func maxVal(a ...int) int {
	max := a[0]
	for _, val := range a[1:] {
		if val > max {
			max = val
		}
	}
	return max
}
```
***
### Используя в качестве примера функцию `makeEvenGenerator` напишите `makeOddGenerator`, генерирующую нечётные числа.
```go
func makeOddGenerator() func() uint {
	i := uint(1)
	return func() (ret uint) {
		ret = i
		i += 2
		return
	}
}
```
***
### Последовательность чисел Фибоначчи определяется как `fib(0) = 0, fib(1) = 1, fib(n) = fib(n-1) + fib(n-2)`. Напишите рекурсивную функцию, находящую `fib(n)`.
```go
func fib(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		return fib(n-1) + fib(n-2)
	}
}
```
***
### Что такое отложенный вызов, паника и восстановление? Как восстановить функцию после паники?
Ключевое слово `defer` определить функцию, вызов которой будет отложен до момента завершения объемлющей функции. Несколько `defer` функций, определённых в одной фукции будут вызваны по принципу LIFO. Системная функция `panic` предназначена для генерации ошибок, которые мы можем обработать при помощи системной функции `recover`, тем самым, восстановив функцию. 